---
title: "Lab 06 - Creating Buffers"
author: "Francisco Santamarina"
date: "March 09, 2017"
output:
  html_document:
    df_print: paged
    keep_md: true

---

```{r setup, include=FALSE}
knitr::opts_chunk$set( message=F, warning=F )
```

## Part 1

Load the necessary packages.
```{r}
#library( censusAPI)
#library( ggmap )
#library( jsonlite )
library( maptools )
library( measurements )
#library( memisc )
#library( RCurl )
library( raster )
library( rgdal )
library( rgeos )
library( sp )
#library( spatialEco ) 

```

Load and clean the necessary dataset.
```{r}
# Set the working directory
#setwd( "//hd.ad.syr.edu/02/7796a1/Documents/Desktop/DDM/DDM II/Lab 06" )
setwd("~/Graduate School/PAI 690 Independent Study_DDM II/Labs/Lab 06_Buffers")
#dir.create( "shapefiles" )
setwd( "./shapefiles" )


# Download shapefiles
download.file("ftp://ftp2.census.gov/geo/tiger/TIGER2010/TRACT/2010/tl_2010_36067_tract10.zip", "onondaga census tracts.zip" )
unzip( "onondaga census tracts.zip" )
file.remove( "onondaga census tracts.zip" )
dir()


# Load and plot shapefiles
syr <- readShapePoly( fn="tl_2010_36067_tract10", proj4string=CRS("+proj=longlat +datum=WGS84") )

par( mar=c(0,0,0,0) )
plot( syr,  border="gray10" )


# Add roads

download.file("ftp://ftp2.census.gov/geo/tiger/TIGER2015/PRISECROADS/tl_2015_36_prisecroads.zip", "primary_and_secondary_roads.zip" )

unzip( "primary_and_secondary_roads.zip" )
file.remove( "primary_and_secondary_roads.zip" )
dir()

roads <- readShapeLines( fn="tl_2015_36_prisecroads", proj4string=CRS("+proj=longlat +datum=WGS84") )

head( roads@data )
table( roads$RTTYP )
class( roads )
#RTTYP = Road Type Code
# C = county
# I = interstate
# M = Common Name
# O = other
# S = state recognized
# U = U.S.
```

#### Create a polygon outline
```{r}
### Get census tracts FIPS, grab all ids of 1-61, dissolve the polygons to get the outline
setwd( "~/Graduate School/PAI 690 Independent Study_DDM II/Labs/shapefiles" )
#download.file("ftp://ftp2.census.gov/geo/tiger/TIGER2010/TRACT/2010/tl_2010_36067_tract10.zip", "onondaga census tracts.zip" )
#unzip( "onondaga census tracts.zip" )
#file.remove( "onondaga census tracts.zip" )
dir()
#syr2 <- readShapePoly( fn="01-05-2015", 
#         proj4string=CRS("+proj=longlat +datum=WGS84") 
#         )
#head( syr2@data) #returns the output of a list of values in syr2 map data
#syr2.subset <- syr2[ as.numeric(as.character(syr2$CensusTrac)) < 62 && as.numeric(as.character(syr2$CensusTrac)) > 0 ]
head( syr@data )
names( syr )
table( syr$GEOID10 )
str( syr$TRACTCE10 )

# Plot only the tracts within the city
# 0 or 1 in the 7th position of the FIPS ID string seem to differentiate city vs rural
# OR only looking at the last 4 is insufficient for a 3-digit census tract ID

last5tract <- unique(substr(syr$GEOID10, 7,11))
table(last5tract)
syr.sub <- syr[ (as.numeric(substr(syr$GEOID10, 7,11)) < 06200 ) & (as.numeric(substr(syr$GEOID10, 7,11)) > 0), ]
head(syr.sub)
plot(syr.sub)
class( syr.sub )
```


#### Clip Roads down to same size as census tracts
```{r}
# Using gClip() to do a modified subsetting of geospatial points/lines
# http://robinlovelace.net/r/2014/07/29/clipping-with-r.html
# rgeos version: 0.3-5, (SVN revision 447)
#  GEOS runtime version: 3.4.2-CAPI-1.8.2 r3921 
#  Polygon checking: TRUE

gClip <- function(shp, bb){  #shp = shapefile, bb = bounding box
  if(class(bb) == "matrix") b_poly <- as(extent(as.vector(t(bb))), "SpatialPolygons")
  else b_poly <- as(extent(bb), "SpatialPolygons")
  gIntersection(shp, b_poly, byid = T)
}

roads.clipped <- gClip(roads, syr)
#this returns a BOX that has the roads limited within it
plot( roads.clipped )
str( roads.clipped )
class( roads.clipped )
# Clip is computationally expensive, has to determine what to do with the polygons destroyed in the clip

# use intersect instead of gClip and syr.sub
## source: https://gis.stackexchange.com/questions/23931/how-to-intersect-lines-and-polygons-in-r
## author: xhie                library(raster)
## newLines <- raster::intersect(SpatialLinesDataframe, SpatialPolygonDataframe)
roads.cropped <- raster::intersect( roads, syr.sub )
plot( roads.cropped )
str( roads.cropped )
class( roads.cropped )
table( roads.cropped$RTTYP )

```


#### Extract the interstates as a separate layer
```{r}
#subset()

# Using roads.clipped

par( mar=c(0,0,0,0) )
plot( syr,  border="gray80" )
#plot( roads, col="steelblue", lwd=2, add=T )
plot( roads.clipped, col="steelblue", lwd=1, add=T )

#interstate <- roads[ roads$RTTYP == "I", ]
interstate1 <- roads.clipped[ roads.clipped$RTTYP == "I", ]
interstate.clipped <- gClip( interstate, syr )
#this returns a BOX that has the interstates limited within it
plot( interstate.clipped, col="red", add=T )



# Using roads.cropped

par( mar=c(0,0,0,0) )
plot( syr.sub,  border="gray80" )
#plot( roads, col="steelblue", lwd=2, add=T )
plot( roads.cropped, col="steelblue", lwd=1, add=T )

#interstate <- roads[ roads$RTTYP == "I", ]
interstate2 <- roads.cropped[ roads.cropped$RTTYP == "I", ]
interstate.cropped <- raster::intersect( interstate2, syr.sub )

plot( interstate.cropped, col="red", add=T )
class( interstate.cropped )
```

#### Create a buffer of approximately a quarter mile from the interstate
```{r}
# To make accurate buffers, use a variant of this:
proj4string( interstate.cropped ) = CRS("+proj=longlat +datum=WGS84") # set it to lat-long
#interstate.projected <- spTransform( interstate.cropped, CRS( "+init=epsg:3347" ) ) 
interstate.projected.US <- spTransform( interstate.cropped, CRS( "+proj=longlat +datum=NAD83" ) )
#interstate.projected <- spTransform( interstate.cropped, proj4string=CRS( "+proj=longlat +datum=WGS84" ) ) 
#gridded( interstate.projected ) = TRUE
rtest = raster( interstate.projected )
plot(rtest)

interstate.projected <- spTransform( interstate.cropped, CRS( "+init=epsg:3347" ) ) 
coordinates(interstate.projected)

class( interstate.projected )

# Approximate Buffer
buffhwy <- gBuffer(
  interstate.cropped,
  #interstate.projected,
  #width = 0.001, # width of buffer
  width = 0.005, # width of buffer
  byid = FALSE # applied across "subgeometries"   IF you do FALSE, will automatically create a dissolved buffer
)
class( buffhwy )
# buffhwy <- SpatialPolygonsDataFrame( buffhwy, data=buffhwy@data)
class( buffhwy )
str( buffhwy )
plot( buffhwy, add=T)


# proj4string(buff1)=CRS("+proj=longlat +datum=WGS84")

```

#### Identify all houses that fall within the buffer zone
```{r}
#dat <- read.csv( "https://raw.githubusercontent.com/lecy/maps-in-R/master/Data/syr_parcels.csv" )
dat <- read.csv( "https://raw.githubusercontent.com/R-Class/all-labs-ddmii-fjsantam/master/Lab%2006/data.csv" )
# For the code used to generate the raw CSV file above, refer to Lab_06_-_Geocoding_CSV_Script_FJS.Rmd in the Lab 06 folder on GitHub
names( dat )
nrow( dat )

# Convert the coordinates that are in lon (x) lat(y) order to spatial points, identifying the coordinates, data, and coordinate system
xy <- dat[ c( "lon", "lat") ]
spdat <- SpatialPointsDataFrame( xy, dat, proj4string=CRS("+proj=longlat +datum=WGS84")  )
class( spdat )
points( spdat )
nrow( spdat )

# Function is: over( locations, layer )
homes.on.highway <- over( spdat, buffhwy )
class( homes.on.highway)

# buff1 is a SpatialPolygon; dat is a dataframe
# will return a list of points (top row) and which polygon they are in (represented by ID # or NA if not in one)
honh.logical <- homes.on.highway[is.na(homes.on.highway)]

honh.logical <- as.character(homes.on.highway) != "NA"
honh.logical[ is.na(honh.logical) ] <- FALSE
class( honh.logical )
```


#### Add a new categorical variable to the houses dataset: within buffer zone or not?
```{r}
dat <- as.data.frame( dat )
dat.buffer <- cbind( dat, honh.logical )

head( dat.buffer )
nrow( dat.buffer )
```


#### Compile the Map
```{r}
par( mar=c(0,0,0,0) )
plot( syr.sub,  border="gray80" )
plot( roads.cropped, col="steelblue", lwd=1, add=T )
plot( buffhwy, add=T)
plot( interstate.cropped, col="red", add=T )

```


## Part 2

#### Create a buffer a quarter mile from industrial zones (LandUse) and plot the buffer zone
```{r}

```

#### Identify houses within the buffer zones and create a categorical variable in the dataset indicating proximity to industrial zones
```{r}

```

#### Create a buffer zone an eighth of a mile from schools, and plot the buffer zone.
```{r}

```

#### Identify houses within the buffer zones and create a categorical variable in the dataset indicating proximity to schools
```{r}

```

